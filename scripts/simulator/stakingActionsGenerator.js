const BN = web3.utils.BN;
const BASE = 100; // base for weighted operations
const { zeroBN, zeroAddress } = require("../../test/helper.js");

//next operation options.
const DEPOSIT = 'deposit';
const DELEGATE = 'delegate';
const WITHDRAW = 'withdraw';
const NO_ACTION = 'null';

module.exports = { DEPOSIT, DELEGATE, WITHDRAW, NO_ACTION }

module.exports.genNextOp = function genNextOp(loop, numRuns) {
    let rand = genRandomSeed(7, BASE);
    let depositWeight;
    let withdrawWeight;
    let delegateWeight;
    // weighted operations
    // at the start, should have more deposits, then taper off
    let startRatio = loop / numRuns;
    if (startRatio < 0.002) {
        depositWeight = 70;
        withdrawWeight = 75;
        delegateWeight = 90;
    } else {
        depositWeight = 35;
        withdrawWeight = 60;
        delegateWeight = 90;
    }

    if (rand < depositWeight) return DEPOSIT;
    if (rand < withdrawWeight) return WITHDRAW;
    if (rand < delegateWeight) return DELEGATE;
    return NO_ACTION;
}

// Option 1: amount should be smaller than staker balance
// Option 2: should be bigger than staker balance
module.exports.genDeposit = async function genDeposit(kncToken, stakers) {
    let result = {
        'staker': '',
        'amount': 0,
        'msg': '',
        'isValid': false
    }

    let rand = genRandomSeed(32, stakers.length);
    result.staker = stakers[rand];
    let tokenBal = (await kncToken.balanceOf(result.staker));
    rand = genRandomSeed(32, BASE);
    if (rand <= 97) {
        result.amount = genRandomBN(zeroBN, tokenBal);
        if (result.amount.eq(zeroBN)) {
            result.msg = 'invalid deposit: 0 amt',
            result.isValid = false;
        } else {
            result.msg = 'valid deposit';
            result.isValid = true;
        }
        
    } else {
        result.amount = genRandomBN(tokenBal.add(new BN(1)), tokenBal.mul(new BN(2)));
        result.msg = 'invalid deposit';
        result.isValid = false;
    }
    return result;
}

// Option 1: Delegate to another address generated by buidler / ganache
// Option 2: Delegate to non-staker
// Option 3: Delegate back to self (un-delegate)
module.exports.genDelegate = async function genDelegate(stakers) {
    let result = {
        'staker': '',
        'dAddress': '',
        'msg': ''
    }

    let rand = genRandomSeed(32, stakers.length);
    result.staker = stakers[rand];
    // by default, set to self (un-delegate)
    result.dAddress = result.staker;
    result.msg = 'delegate to self (un-delegate)';
    rand = genRandomSeed(32, BASE);
    if (rand <= 60) {
        while (result.staker == result.dAddress) {
            let rand2 = genRandomSeed(32, stakers.length);
            result.dAddress = stakers[rand2];
        }
        result.msg = 'delegate to another staker';
    } else if (rand <= 65) {
        let randomPrivateKey = web3.utils.sha3("Katalyst gonna be dope" + rand);
        result.dAddress = (web3.eth.accounts.privateKeyToAccount(randomPrivateKey)).address;
        if (result.dAddress == zeroAddress) {
            result.msg = 'delegate to null address: expect failure';
        }
        result.msg = 'delegate to non-staker';
    }
    return result;
}

// Option 1: Withdraw amount less than deposit amt made so far
// Option 2: Withdraw amount greater than deposit made so far
// Option 3: Withdraw amount greater than full stake amount
module.exports.genWithdraw = async function genWithdraw(stakingContract, stakers) {
    let result = {
        'staker': '',
        'amount': 0,
        'msg': '',
        isValid: false
    }

    let rand = genRandomSeed(32, stakers.length);
    result.staker = stakers[rand];
    rand = genRandomSeed(32, BASE);
    let latestStake = await stakingContract.getLatestStakeBalance(result.staker);
    let curEpochNum = await stakingContract.getCurrentEpochNumber();
    let curEpochStake = await stakingContract.getStake(result.staker, curEpochNum);
    let depositMadeInCurEpoch = latestStake.sub(curEpochStake);
    if (rand <= 44) {
        result.amount = genRandomBN(zeroBN, depositMadeInCurEpoch);
        if (result.amount.eq(zeroBN)) {
            result.msg = 'withdraw zero, should fail';
            result.isValid = false;
        } else {
            result.msg = 'withdrawal <= deposit so far';
            result.isValid = true;
        }
    } else if (rand <= 88) {
        result.amount = genRandomBN(depositMadeInCurEpoch, latestStake);
        if (result.amount.eq(zeroBN)) {
            result.msg = 'withdraw zero, should fail';
            result.isValid = false;
        } else {
            result.msg = 'withdrawal > deposit so far';
            result.isValid = true;
        }
    } else {
        result.amount = genRandomBN(latestStake, latestStake.mul(new BN(2)));
        result.msg = 'withdrawal > stake';
        result.isValid = false;
    }

    return result;
}

function genRandomSeed(length, base) {
    return (web3.utils.randomHex(length)) % base;
}
function genRandomBN(minBN, maxBN) {
    let seed = new BN(genRandomSeed(32, 1000000000000000));
    // normalise seed
    return (maxBN.sub(minBN).mul(seed).div(new BN(1000000000000000))).add(minBN);
}
